/*
 * Filename: sc_event_type.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 *
 * description: Signalclass
 * name: sc_event
 * shortname: event
 *
 */

#include "project.h"
#include "global.h"
#include "rte.h"
#include "rte_types.h"
#include "sc_event_type.h"



/* USER CODE START SC_EVENT_INCLUDE */
#include "Button_3.h"
#include "Button_4.h"
/* USER CODE END SC_EVENT_INCLUDE */




/* USER CODE START SC_EVENT_USERDEFINITIONS */
#define LONG_PRESS_THRESHOLD    20      // 20 x 50ms = 1 second
#define EV_1MIN_THRESHOLD       1200    // 1200 x 50ms = 1 minute
#define EV_250MS_THRESHOLD      5       // 20 x 50ms = 1 second
/* USER CODE END SC_EVENT_USERDEFINITIONS */


/*****************************************************************************************
 *************** Port Wrapper Implementation for SC_EVENT signal  ****************
 *****************************************************************************************/
 
 

/**
 * Default IN driver API
 */
inline RC_t SC_EVENT_driverIn(SC_EVENT_data_t *const data)
{
	/* USER CODE START driverInSC_EVENT */
    static boolean_t lastButton3State = FALSE;
    static boolean_t lastButton4State = FALSE;
    static uint16_t button4PressDuration = 0;
    static uint16_t tick250msCounter = 0;
    static uint32_t tick1minCounter = 0;
    
    boolean_t currentButton3State = Button_3_Read();
    boolean_t currentButton4State = Button_4_Read();

    data->m_ev = EV_NONE;

    if (currentButton3State && !lastButton3State) {
        data->m_ev = EV_KEYLEFT;
    }

    if (currentButton4State) {
        button4PressDuration++;
    } else {
        if (lastButton4State) {
            if (button4PressDuration >= LONG_PRESS_THRESHOLD) {
                data->m_ev = EV_KEYRIGHTLONGPRESS;
            } else if (button4PressDuration > 0) {
                data->m_ev = EV_KEYRIGHT;
            }
            button4PressDuration = 0;
        }
    }

    lastButton3State = currentButton3State;
    lastButton4State = currentButton4State;
    

    if (tick250msCounter++ >= EV_250MS_THRESHOLD) {
        data->m_ev = EV_250MS;
        tick250msCounter = 0;
    }
    
    if (tick1minCounter++ >= EV_1MIN_THRESHOLD) {
        data->m_ev = EV_1MIN;
        tick1minCounter = 0;
    }
    
	return RC_SUCCESS;
	/* USER CODE END driverInSC_EVENT */
}
/**
 * Default OUT driver API
 */
inline RC_t SC_EVENT_driverOut(const SC_EVENT_data_t  *const data)
{
	/* USER CODE START driverOutSC_EVENT */

	//Scale application data to drive format

	//Write scaled data to driver

	return RC_SUCCESS;
	/* USER CODE END driverOutSC_EVENT */
}



